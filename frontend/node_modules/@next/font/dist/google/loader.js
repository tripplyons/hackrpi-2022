"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
const font_utils_1 = require("next/dist/server/font-utils");
// @ts-ignore
const Log = __importStar(require("next/dist/build/output/log"));
// @ts-ignore
const chalk_1 = __importDefault(require("next/dist/compiled/chalk"));
// @ts-ignore
const utils_1 = require("./utils");
const cssCache = new Map();
const fontCache = new Map();
const downloadGoogleFonts = async ({ functionName, data, config, emitFontFile, isServer, }) => {
    var _a, _b;
    const subsets = (config === null || config === void 0 ? void 0 : config.subsets) || [];
    const { fontFamily, weights, styles, display, preload, selectedVariableAxes, fallback, adjustFontFallback, variable, subsets: callSubsets, } = (0, utils_1.validateData)(functionName, data);
    if (isServer && preload && !callSubsets && !(config === null || config === void 0 ? void 0 : config.subsets)) {
        Log.warn(`The ${chalk_1.default.bold('@next/font/google')} font ${chalk_1.default.bold(fontFamily)} has no selected subsets. Please specify subsets in the function call or in your ${chalk_1.default.bold('next.config.js')}, otherwise no fonts will be preloaded. Read more: https://nextjs.org/docs/messages/google-fonts-missing-subsets`);
    }
    const fontAxes = (0, utils_1.getFontAxes)(fontFamily, weights, styles, selectedVariableAxes);
    const url = (0, utils_1.getUrl)(fontFamily, fontAxes, display);
    let cachedCssRequest = cssCache.get(url);
    const fontFaceDeclarations = cachedCssRequest !== null && cachedCssRequest !== void 0 ? cachedCssRequest : (await (0, utils_1.fetchCSSFromGoogleFonts)(url, fontFamily));
    if (!cachedCssRequest) {
        cssCache.set(url, fontFaceDeclarations);
    }
    else {
        cssCache.delete(url);
    }
    // Find font files to download
    const fontFiles = [];
    let currentSubset = '';
    for (const line of fontFaceDeclarations.split('\n')) {
        // Each @font-face has the subset above it in a comment
        const newSubset = (_a = /\/\* (.+?) \*\//.exec(line)) === null || _a === void 0 ? void 0 : _a[1];
        if (newSubset) {
            currentSubset = newSubset;
        }
        else {
            const googleFontFileUrl = (_b = /src: url\((.+?)\)/.exec(line)) === null || _b === void 0 ? void 0 : _b[1];
            if (googleFontFileUrl) {
                fontFiles.push({
                    googleFontFileUrl,
                    preloadFontFile: !!preload && (callSubsets !== null && callSubsets !== void 0 ? callSubsets : subsets).includes(currentSubset),
                });
            }
        }
    }
    // Download font files
    const downloadedFiles = await Promise.all(fontFiles.map(async ({ googleFontFileUrl, preloadFontFile }) => {
        let cachedFontRequest = fontCache.get(googleFontFileUrl);
        const fontFileBuffer = cachedFontRequest !== null && cachedFontRequest !== void 0 ? cachedFontRequest : (await (0, utils_1.fetchFontFile)(googleFontFileUrl));
        if (!cachedFontRequest) {
            fontCache.set(googleFontFileUrl, fontFileBuffer);
        }
        else {
            fontCache.delete(googleFontFileUrl);
        }
        const ext = /\.(woff|woff2|eot|ttf|otf)$/.exec(googleFontFileUrl)[1];
        // Emit font file to .next/static/fonts
        const selfHostedFileUrl = emitFontFile(fontFileBuffer, ext, preloadFontFile);
        return {
            googleFontFileUrl,
            selfHostedFileUrl,
        };
    }));
    // Replace @font-face sources with self-hosted files
    let updatedCssResponse = fontFaceDeclarations;
    for (const { googleFontFileUrl, selfHostedFileUrl } of downloadedFiles) {
        updatedCssResponse = updatedCssResponse.replace(googleFontFileUrl, selfHostedFileUrl);
    }
    // Add fallback font
    let adjustFontFallbackMetrics;
    if (adjustFontFallback) {
        try {
            const { ascent, descent, lineGap, fallbackFont, sizeAdjust } = (0, font_utils_1.calculateSizeAdjustValues)(require('next/dist/server/google-font-metrics.json')[fontFamily]);
            adjustFontFallbackMetrics = {
                fallbackFont,
                ascentOverride: `${ascent}%`,
                descentOverride: `${descent}%`,
                lineGapOverride: `${lineGap}%`,
                sizeAdjust: `${sizeAdjust}%`,
            };
        }
        catch {
            Log.error(`Failed to find font override values for font \`${fontFamily}\``);
        }
    }
    return {
        css: updatedCssResponse,
        fallbackFonts: fallback,
        weight: weights.length === 1 && weights[0] !== 'variable'
            ? weights[0]
            : undefined,
        style: styles.length === 1 ? styles[0] : undefined,
        variable,
        adjustFontFallback: adjustFontFallbackMetrics,
    };
};
exports.default = downloadGoogleFonts;
